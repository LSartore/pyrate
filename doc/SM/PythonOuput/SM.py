#########################################################
##  This file was automatically generated by PyR@TE 3  ##
###                                                   ###
##                                                     ##
#  Model  : SM                                          #
#  Author : Lohan Sartore                               #
#  Date   : 01.04.2020                                  #
#########################################################

import time
import numpy as np
from sympy import flatten
from scipy.integrate import ode
import matplotlib.pyplot as plt

class Coupling():
    couplings = {}

    def __init__(self, name, couplingType, latex=None, shape = (), fromMat=None, cplx=False, init=0, pos=None):
        self.name = name
        self.type = couplingType

        if latex is not None:
            self.latex = latex
        else:
            self.latex = self.name

        self.shape = shape
        self.is_matrix = ( shape != () )
        self.nb = self.shape[0]*self.shape[1] if self.is_matrix else 1
        self.cplx = cplx

        self.initialValue = init if shape == () else np.zeros(shape)
        # self.initialValue = np.random.rand() - .5 if shape == () else np.zeros(shape)

        if fromMat is not None:
            self.pos = pos
            self.latex = '{' + fromMat.latex + '}' + self.name.replace(fromMat.name, '')
            return

        if couplingType not in self.couplings:
            self.couplings[couplingType] = []

        self.pos = sum([c.nb for cList in self.couplings.values() for c in cList])
        self.couplings[couplingType].append(self)

    def as_explicit(self, toList=False):
        if not self.is_matrix:
            return self

        nameFunc = lambda x: self.name+'_{' + str(1 + x // self.shape[0]) + str(1 + x % self.shape[1]) + '}'
        initFunc = lambda x: list(self.initialValue)[x // self.shape[0]][x % self.shape[1]]
        arrayFunc = np.vectorize(lambda x: Coupling(nameFunc(x), self.type, fromMat=self, init=initFunc(x), pos=self.pos+x))
        array = arrayFunc(np.reshape(range(self.nb), self.shape))

        if not toList:
            return array

        return [*array.flat]


class RGEsolver():
    """ This class contains the RGEs of the model, as well as pre-defined functions
    used to solve and plot them.

    The three following arguments may be provided:
        - initialScale:
            The energy scale at which the initial values are given
        - tmin, tmax :
            The lower and upper energy scales between which the running couplings are computed and plotted

    The initialScale can be different from tmin and tmax, the only requirement being that the initial value of the
    couplings are all given at the same scale."""

    translation = {'GaugeCouplings': 'Gauge Couplings',
                   'Yukawas': 'Yukawa Couplings',
                   'QuarticTerms': 'Quartic Couplings',
                   'TrilinearTerms' : 'Trilinear Couplings',
                   'ScalarMasses': 'Scalar Mass Couplings',
                   'FermionMasses': 'Fermion Mass Couplings',
                   'Vevs': 'Vacuum-expectation Values'}

    def __init__(self, name, initialScale = 0, tmin = 0, tmax = 20):
        if initialScale < tmin or initialScale > tmax:
            exit(f"The initial running scale must lie in the interval [tmin={tmin}, tmax={tmax}]")

        self.name = name
        Coupling.couplings = {}

        self.initialScale = initialScale
        self.tmin = tmin
        self.tmax = tmax

        self.kappa = lambda n: 1/(4*np.pi)**(2*n)

        self.tList = []
        self.solutions = {}
        self.loops = {'GaugeCouplings' : 2, 
                           'Yukawas' : 2, 
                           'QuarticTerms' : 2, 
                           'ScalarMasses' : 2, 
                           'Vevs' : 2}

        # Gauge Couplings
        self.g1 = Coupling('g1', 'GaugeCouplings', latex='g_1')
        self.g2 = Coupling('g2', 'GaugeCouplings', latex='g_2')
        self.g3 = Coupling('g3', 'GaugeCouplings', latex='g_3')

        # Yukawa Couplings
        self.yt = Coupling('yt', 'Yukawas', latex='y_t')
        self.yb = Coupling('yb', 'Yukawas', latex='y_b')
        self.ytau = Coupling('ytau', 'Yukawas', latex='y_\\tau')

        # Quartic Couplings
        self.lambda_ = Coupling('lambda_', 'QuarticTerms', latex='\\lambda')

        # Scalar Mass Couplings
        self.mu = Coupling('mu', 'ScalarMasses', latex='\\mu')

        # Vacuum-expectation Values
        self.v = Coupling('v', 'Vevs')

        self.couplings = Coupling.couplings



    def extractCouplings(self, couplingsArray, couplingType):
        ret = []
        for c in self.couplings[couplingType]:
            if not c.is_matrix:
                ret.append(couplingsArray[c.pos])
            else:
                ret.append(np.matrix(np.reshape([couplingsArray[p] for p in range(c.pos, c.pos+c.nb)], c.shape)))
        return ret
        

    def betaFunction(self, t, couplingsArray):
        """ This function contains the expression of the various RGEs of the model. It is called by the
            solver to provide the derivative of the couplings with respect to the energy scale."""

        g1, g2, g3 = self.extractCouplings(couplingsArray, 'GaugeCouplings')
        yt, yb, ytau = self.extractCouplings(couplingsArray, 'Yukawas')
        lambda_, = self.extractCouplings(couplingsArray, 'QuarticTerms')
        mu, = self.extractCouplings(couplingsArray, 'ScalarMasses')
        v, = self.extractCouplings(couplingsArray, 'Vevs')

        bg1, bg2, bg3 = 3*[0]
        byt, byb, bytau = 3*[0]
        blambda_ = 0
        bmu = 0
        bv = 0

        if self.loops['GaugeCouplings'] >= 1:
            bg1 += ((41/10)*g1**3)*self.kappa(1)*np.log(10)
            bg2 += (-19/6*g2**3)*self.kappa(1)*np.log(10)
            bg3 += (-7*g3**3)*self.kappa(1)*np.log(10)
        if self.loops['GaugeCouplings'] >= 2:
            bg1 += ((199/50)*g1**5 + (27/10)*g1**3*g2**2 + (44/5)*g1**3*g3**2 - 1/2*g1**3*abs(yb)**2 - 17/10*g1**3*abs(yt)**2 - 3/2*g1**3*abs(ytau)**2)*self.kappa(2)**2*np.log(10)
            bg2 += ((9/10)*g1**2*g2**3 + (35/6)*g2**5 + 12*g2**3*g3**2 - 3/2*g2**3*abs(yb)**2 - 3/2*g2**3*abs(yt)**2 - 1/2*g2**3*abs(ytau)**2)*self.kappa(2)**2*np.log(10)
            bg3 += ((11/10)*g1**2*g3**3 + (9/2)*g2**2*g3**3 - 26*g3**5 - 2*g3**3*abs(yb)**2 - 2*g3**3*abs(yt)**2)*self.kappa(2)**2*np.log(10)

        if self.loops['Yukawas'] >= 1:
            byt += (-17/20*g1**2*yt - 9/4*g2**2*yt - 8*g3**2*yt + (3/2)*yt*abs(yb)**2 + (9/2)*yt*abs(yt)**2 + yt*abs(ytau)**2)*self.kappa(1)*np.log(10)
            byb += (-1/4*g1**2*yb - 9/4*g2**2*yb - 8*g3**2*yb + (9/2)*yb*abs(yb)**2 + (3/2)*yb*abs(yt)**2 + yb*abs(ytau)**2)*self.kappa(1)*np.log(10)
            bytau += (-9/4*g1**2*ytau - 9/4*g2**2*ytau + 3*ytau*abs(yb)**2 + 3*ytau*abs(yt)**2 + (5/2)*ytau*abs(ytau)**2)*self.kappa(1)*np.log(10)
        if self.loops['Yukawas'] >= 2:
            byt += ((1187/600)*g1**4*yt - 9/20*g1**2*g2**2*yt + (19/15)*g1**2*g3**2*yt + (7/80)*g1**2*yt*abs(yb)**2 + (393/80)*g1**2*yt*abs(yt)**2 + (15/8)*g1**2*yt*abs(ytau)**2 - 23/4*g2**4*yt + 9*g2**2*g3**2*yt + (99/16)*g2**2*yt*abs(yb)**2 + (225/16)*g2**2*yt*abs(yt)**2 + (15/8)*g2**2*yt*abs(ytau)**2 - 108*g3**4*yt + 4*g3**2*yt*abs(yb)**2 + 36*g3**2*yt*abs(yt)**2 + 6*lambda_**2*yt - 12*lambda_*yt*abs(yt)**2 - 1/4*yt*abs(yb)**4 - 11/4*yt*abs(yb)**2*abs(yt)**2 + (5/4)*yt*abs(yb)**2*abs(ytau)**2 - 12*yt*abs(yt)**4 - 9/4*yt*abs(yt)**2*abs(ytau)**2 - 9/4*yt*abs(ytau)**4)*self.kappa(2)**2*np.log(10)
            byb += (-127/600*g1**4*yb - 27/20*g1**2*g2**2*yb + (31/15)*g1**2*g3**2*yb + (237/80)*g1**2*yb*abs(yb)**2 + (91/80)*g1**2*yb*abs(yt)**2 + (15/8)*g1**2*yb*abs(ytau)**2 - 23/4*g2**4*yb + 9*g2**2*g3**2*yb + (225/16)*g2**2*yb*abs(yb)**2 + (99/16)*g2**2*yb*abs(yt)**2 + (15/8)*g2**2*yb*abs(ytau)**2 - 108*g3**4*yb + 36*g3**2*yb*abs(yb)**2 + 4*g3**2*yb*abs(yt)**2 + 6*lambda_**2*yb - 12*lambda_*yb*abs(yb)**2 - 12*yb*abs(yb)**4 - 11/4*yb*abs(yb)**2*abs(yt)**2 - 9/4*yb*abs(yb)**2*abs(ytau)**2 - 1/4*yb*abs(yt)**4 + (5/4)*yb*abs(yt)**2*abs(ytau)**2 - 9/4*yb*abs(ytau)**4)*self.kappa(2)**2*np.log(10)
            bytau += ((1371/200)*g1**4*ytau + (27/20)*g1**2*g2**2*ytau + (5/8)*g1**2*ytau*abs(yb)**2 + (17/8)*g1**2*ytau*abs(yt)**2 + (537/80)*g1**2*ytau*abs(ytau)**2 - 23/4*g2**4*ytau + (45/8)*g2**2*ytau*abs(yb)**2 + (45/8)*g2**2*ytau*abs(yt)**2 + (165/16)*g2**2*ytau*abs(ytau)**2 + 20*g3**2*ytau*abs(yb)**2 + 20*g3**2*ytau*abs(yt)**2 + 6*lambda_**2*ytau - 12*lambda_*ytau*abs(ytau)**2 - 27/4*ytau*abs(yb)**4 + (3/2)*ytau*abs(yb)**2*abs(yt)**2 - 27/4*ytau*abs(yb)**2*abs(ytau)**2 - 27/4*ytau*abs(yt)**4 - 27/4*ytau*abs(yt)**2*abs(ytau)**2 - 3*ytau*abs(ytau)**4)*self.kappa(2)**2*np.log(10)

        if self.loops['QuarticTerms'] >= 1:
            blambda_ += ((27/200)*g1**4 + (9/20)*g1**2*g2**2 - 9/5*g1**2*lambda_ + (9/8)*g2**4 - 9*g2**2*lambda_ + 24*lambda_**2 + 12*lambda_*abs(yb)**2 + 12*lambda_*abs(yt)**2 + 4*lambda_*abs(ytau)**2 - 6*abs(yb)**4 - 6*abs(yt)**4 - 2*abs(ytau)**4)*self.kappa(1)*np.log(10)
        if self.loops['QuarticTerms'] >= 2:
            blambda_ += (-3411/2000*g1**6 - 1677/400*g1**4*g2**2 + (1887/200)*g1**4*lambda_ + (9/20)*g1**4*abs(yb)**2 - 171/100*g1**4*abs(yt)**2 - 9/4*g1**4*abs(ytau)**2 - 289/80*g1**2*g2**4 + (117/20)*g1**2*g2**2*lambda_ + (27/10)*g1**2*g2**2*abs(yb)**2 + (63/10)*g1**2*g2**2*abs(yt)**2 + (33/10)*g1**2*g2**2*abs(ytau)**2 + (108/5)*g1**2*lambda_**2 + (5/2)*g1**2*lambda_*abs(yb)**2 + (17/2)*g1**2*lambda_*abs(yt)**2 + (15/2)*g1**2*lambda_*abs(ytau)**2 + (4/5)*g1**2*abs(yb)**4 - 8/5*g1**2*abs(yt)**4 - 12/5*g1**2*abs(ytau)**4 + (305/16)*g2**6 - 73/8*g2**4*lambda_ - 9/4*g2**4*abs(yb)**2 - 9/4*g2**4*abs(yt)**2 - 3/4*g2**4*abs(ytau)**2 + 108*g2**2*lambda_**2 + (45/2)*g2**2*lambda_*abs(yb)**2 + (45/2)*g2**2*lambda_*abs(yt)**2 + (15/2)*g2**2*lambda_*abs(ytau)**2 + 80*g3**2*lambda_*abs(yb)**2 + 80*g3**2*lambda_*abs(yt)**2 - 32*g3**2*abs(yb)**4 - 32*g3**2*abs(yt)**4 - 312*lambda_**3 - 144*lambda_**2*abs(yb)**2 - 144*lambda_**2*abs(yt)**2 - 48*lambda_**2*abs(ytau)**2 - 3*lambda_*abs(yb)**4 - 42*lambda_*abs(yb)**2*abs(yt)**2 - 3*lambda_*abs(yt)**4 - lambda_*abs(ytau)**4 + 30*abs(yb)**6 - 6*abs(yb)**4*abs(yt)**2 - 6*abs(yb)**2*abs(yt)**4 + 30*abs(yt)**6 + 10*abs(ytau)**6)*self.kappa(2)**2*np.log(10)

        if self.loops['ScalarMasses'] >= 1:
            bmu += (-9/10*g1**2*mu - 9/2*g2**2*mu + 12*lambda_*mu + 6*mu*abs(yb)**2 + 6*mu*abs(yt)**2 + 2*mu*abs(ytau)**2)*self.kappa(1)*np.log(10)
        if self.loops['ScalarMasses'] >= 2:
            bmu += ((1671/400)*g1**4*mu + (9/8)*g1**2*g2**2*mu + (72/5)*g1**2*lambda_*mu + (5/4)*g1**2*mu*abs(yb)**2 + (17/4)*g1**2*mu*abs(yt)**2 + (15/4)*g1**2*mu*abs(ytau)**2 - 145/16*g2**4*mu + 72*g2**2*lambda_*mu + (45/4)*g2**2*mu*abs(yb)**2 + (45/4)*g2**2*mu*abs(yt)**2 + (15/4)*g2**2*mu*abs(ytau)**2 + 40*g3**2*mu*abs(yb)**2 + 40*g3**2*mu*abs(yt)**2 - 60*lambda_**2*mu - 72*lambda_*mu*abs(yb)**2 - 72*lambda_*mu*abs(yt)**2 - 24*lambda_*mu*abs(ytau)**2 - 27/2*mu*abs(yb)**4 - 21*mu*abs(yb)**2*abs(yt)**2 - 27/2*mu*abs(yt)**4 - 9/2*mu*abs(ytau)**4)*self.kappa(2)**2*np.log(10)

        if self.loops['Vevs'] >= 1:
            bv += ((3/5)*g1**2*v + 3*g2**2*v - 3*v*abs(yb)**2 - 3*v*abs(yt)**2 - v*abs(ytau)**2)*self.kappa(1)*np.log(10)
        if self.loops['Vevs'] >= 2:
            bv += (-1221/800*g1**4*v + (9/16)*g1**2*g2**2*v - 43/40*g1**2*v*abs(yb)**2 - 103/40*g1**2*v*abs(yt)**2 - 81/40*g1**2*v*abs(ytau)**2 + (199/32)*g2**4*v - 63/8*g2**2*v*abs(yb)**2 - 63/8*g2**2*v*abs(yt)**2 - 21/8*g2**2*v*abs(ytau)**2 - 20*g3**2*v*abs(yb)**2 - 20*g3**2*v*abs(yt)**2 - 6*lambda_**2*v + (27/4)*v*abs(yb)**4 - 3/2*v*abs(yb)**2*abs(yt)**2 + (27/4)*v*abs(yt)**4 + (9/4)*v*abs(ytau)**4)*self.kappa(2)**2*np.log(10)

        return [bg1, bg2, bg3, byt, byb, bytau, blambda_, bmu, bv]

    def printInitialConditions(self, returnString=False):
        """ This function displays the current running scheme and the initial values of the couplings.

        Its output may be copy-pasted 'as-is' by user to modify these parameters before solving the RGEs."""

        # Display the running scheme

        outputString = "\n# Running scheme :\n\n"

        s = f"{self.name}.loops = "
        outputString += s + str(self.loops).replace(', ', ',\n ' + ' '*len(s)) + '\n'

        # Display the initial values of the couplings
        for cType, cList in self.couplings.items():
            outputString += f"\n# {self.translation[cType]}\n\n"
            for c in cList:
                s = f"{self.name}.{c.name}.initialValue = "
                if not c.is_matrix:
                    s += str(c.initialValue)
                else:
                    sVal = '['
                    sVal += (',\n ' +  len(s)*' ').join([ str(el).replace(' ', ', ') for el in c.initialValue])
                    sVal += ']\n'
                    s += sVal
                outputString += s + '\n'

        if returnString:
            return outputString

        print(outputString)

    ##################
    # Solve function #
    ##################

    def solve(self, step=.1, Npoints=None):
        """ This function performs the actual solving of the system of RGEs, using scipy.ode.

        Either the step of the numerical integration may be provided by the user with 'step=[value]',
        OR the number of integration points with 'Npoints=[integer value]'."""

        self.allCouplings = flatten([c.as_explicit(toList=True) for cList in self.couplings.values() for c in cList])

        time0 = time.time()
        y0 = flatten([(c.initialValue if not c.is_matrix else [*c.initialValue.flat]) for c in self.allCouplings])

        tmin = self.tmin
        tmax = self.tmax
        t0 = self.initialScale

        if Npoints is None:
            dt = step
        else:
            dt = (tmax-tmin)/(Npoints-1)

        solutions = {}
        for c in self.allCouplings:
            solutions[c.name] = []
        tList = []

        solver = ode(self.betaFunction).set_integrator('zvode', method='bdf')
        solver.set_initial_value(y0, t0)

        # Solve upwards
        while solver.successful() and solver.t < tmax:
            tList.append(solver.t)
            for i, c in enumerate(self.allCouplings):
                y = solver.y[i]
                if abs(y.imag) > 1e-10 and not c.cplx:
                    c.cplx = True
                elif y.imag == 0:
                    y = y.real

                solutions[c.name].append(y)

            solver.integrate(solver.t+dt)

        if t0 > tmin:
        # If t0 > tmin, complete the solving going downwards
            solutions2 = {}
            for c in self.allCouplings:
                solutions2[c.name] = []
            tList2 = []

            solver.set_initial_value(y0, t0)
            # Solve downwards
            while solver.successful() and solver.t > tmin:
                solver.integrate(solver.t-dt)

                tList2.append(solver.t)
                for i, c in enumerate(self.allCouplings):
                    y = solver.y[i]
                    if abs(y.imag) > 1e-10 and not c.cplx:
                        c.cplx = True
                    elif y.imag == 0:
                        y = y.real

                    solutions2[c.name].append(y)


            # Combine the two regions
            tList = tList2[::-1] + tList
            for c in self.allCouplings:
                solutions[c.name] = solutions2[c.name][::-1] + solutions[c.name]

        self.tList, self.solutions = tList, solutions

        print(f"System of RGEs solved in {time.time()-time0:.3f} seconds.")

    #################
    # Plot function #
    #################

    subPos = {1: [111], 2: [121, 122], 3:[221, 222, 212],
              4: [221, 222, 223, 224], 5:[231, 232, 233, 223, 224],
              6: [231, 232, 233, 234, 235, 236],
              7: [241, 242, 243, 244, 231, 232, 233]}

    def plot(self, figSize=(600, 600), subPlots=True, which=None, whichNot=None, printLoopLevel=True):
        """ We finally plot the running couplings.

        Several options may be given to this function:
            - figSize=(x,y):
                The figure dimensions in pixels.
            - subPlots=True/False :
                If True, plot all the various couplings in the same window. If False,
                produces one figure by coupling type.
            - which=... :
                The user may want to plot only one or several types of couplings. Usage:

                >>> which='GaugeCouplings'

                >>> which=('GaugeCouplings', 'QuarticTerms')

            - whichNot=... :
                Which coupling types are NOT to be plotted. Same usage as which.
            - printLoopLevel=True/False :
                The loop-levels of the computation are displayed in the title of the plots.
        """

        if self.solutions == {}:
            print("The system of RGEs must be solved before plotting the results.")
            return

        allCouplingsByType = {cType:[] for cType in self.couplings}

        for c in self.allCouplings:
            if not all([el == 0 for el in self.solutions[c.name]]):
                allCouplingsByType[c.type].append(c)

        # Remove the coupling types with only identically vanishing couplings
        # + take into account 'which' and 'whichNot' keywords
        if type(which) == str:
            which = (which,)
        if type(whichNot) == str:
            whichNot = (whichNot,)

        for cType, cList in list(allCouplingsByType.items()):
            toDelete = False
            if cList == []:
                toDelete = True
            if which is not None and cType not in which:
                toDelete = True
            if whichNot is not None and cType in whichNot:
                toDelete = True
            if toDelete:
                del allCouplingsByType[cType]

        if subPlots:
            plt.figure(figsize=(figSize[0]/80., figSize[0]/80.), dpi=80)

        for i, (cType, cList) in enumerate(allCouplingsByType.items()):
            title = self.translation[cType]
            if printLoopLevel:
                title = f"{self.loops[cType]}-loop " + title
            if not subPlots:
                plt.figure(figsize=(figSize[0]/80., figSize[0]/80.), dpi=80)
                plt.suptitle(title)
            else:
                plt.subplot(self.subPos[len(allCouplingsByType)][i])
                plt.title(title)

            cNames = []
            for c in cList:
                if not c.cplx:
                    plt.plot(self.tList, self.solutions[c.name])
                    cNames.append('$' + c.latex + '$')
                else:
                    plt.plot(self.tList, np.real(self.solutions[c.name]))
                    plt.plot(self.tList, np.imag(self.solutions[c.name]))
                    cNames.append('$\\Re(' + c.latex + ')$')
                    cNames.append('$\\Im(' + c.latex + ')$')

            plt.legend(cNames)
            plt.xlabel(r't',fontsize=17-len(allCouplingsByType))

