#####################################################################
#       This file was automatically generated by PyR@TE 3.
# It contains the expressions of the RGEs of the model 'SM'.
#####################################################################

import numpy as np

tr = lambda x: np.trace(x)
adjoint = lambda x: x.H
transpose = lambda x: x.transpose()
conjugate = lambda x: np.conjugate(x)


###################
# Gauge Couplings #
###################

def beta_g1(nLoop, g1,g2,g3,yt,yb,ytau):
    if nLoop == 1:
        return (41/10)*g1**3
    if nLoop == 2:
        return (199/50)*g1**5 + (27/10)*g1**3*g2**2 + (44/5)*g1**3*g3**2 - 1/2*g1**3*abs(yb)**2 - 17/10*g1**3*abs(yt)**2 - 3/2*g1**3*abs(ytau)**2

def beta_g2(nLoop, g2,g1,g3,yt,yb,ytau):
    if nLoop == 1:
        return -19/6*g2**3
    if nLoop == 2:
        return (9/10)*g1**2*g2**3 + (35/6)*g2**5 + 12*g2**3*g3**2 - 3/2*g2**3*abs(yb)**2 - 3/2*g2**3*abs(yt)**2 - 1/2*g2**3*abs(ytau)**2

def beta_g3(nLoop, g3,g1,g2,yt,yb):
    if nLoop == 1:
        return -7*g3**3
    if nLoop == 2:
        return (11/10)*g1**2*g3**3 + (9/2)*g2**2*g3**3 - 26*g3**5 - 2*g3**3*abs(yb)**2 - 2*g3**3*abs(yt)**2


####################
# Yukawa Couplings #
####################

def beta_yt(nLoop, g1,g2,g3,yt,yb,ytau,lambda_):
    if nLoop == 1:
        return -17/20*g1**2*yt - 9/4*g2**2*yt - 8*g3**2*yt + (3/2)*yt*abs(yb)**2 + (9/2)*yt*abs(yt)**2 + yt*abs(ytau)**2
    if nLoop == 2:
        return (1187/600)*g1**4*yt - 9/20*g1**2*g2**2*yt + (19/15)*g1**2*g3**2*yt + (7/80)*g1**2*yt*abs(yb)**2 + (393/80)*g1**2*yt*abs(yt)**2 + (15/8)*g1**2*yt*abs(ytau)**2 - 23/4*g2**4*yt + 9*g2**2*g3**2*yt + (99/16)*g2**2*yt*abs(yb)**2 + (225/16)*g2**2*yt*abs(yt)**2 + (15/8)*g2**2*yt*abs(ytau)**2 - 108*g3**4*yt + 4*g3**2*yt*abs(yb)**2 + 36*g3**2*yt*abs(yt)**2 + 6*lambda_**2*yt - 12*lambda_*yt*abs(yt)**2 - 1/4*yt*abs(yb)**4 - 11/4*yt*abs(yb)**2*abs(yt)**2 + (5/4)*yt*abs(yb)**2*abs(ytau)**2 - 12*yt*abs(yt)**4 - 9/4*yt*abs(yt)**2*abs(ytau)**2 - 9/4*yt*abs(ytau)**4

def beta_yb(nLoop, g1,g2,g3,yt,yb,ytau,lambda_):
    if nLoop == 1:
        return -1/4*g1**2*yb - 9/4*g2**2*yb - 8*g3**2*yb + (9/2)*yb*abs(yb)**2 + (3/2)*yb*abs(yt)**2 + yb*abs(ytau)**2
    if nLoop == 2:
        return -127/600*g1**4*yb - 27/20*g1**2*g2**2*yb + (31/15)*g1**2*g3**2*yb + (237/80)*g1**2*yb*abs(yb)**2 + (91/80)*g1**2*yb*abs(yt)**2 + (15/8)*g1**2*yb*abs(ytau)**2 - 23/4*g2**4*yb + 9*g2**2*g3**2*yb + (225/16)*g2**2*yb*abs(yb)**2 + (99/16)*g2**2*yb*abs(yt)**2 + (15/8)*g2**2*yb*abs(ytau)**2 - 108*g3**4*yb + 36*g3**2*yb*abs(yb)**2 + 4*g3**2*yb*abs(yt)**2 + 6*lambda_**2*yb - 12*lambda_*yb*abs(yb)**2 - 12*yb*abs(yb)**4 - 11/4*yb*abs(yb)**2*abs(yt)**2 - 9/4*yb*abs(yb)**2*abs(ytau)**2 - 1/4*yb*abs(yt)**4 + (5/4)*yb*abs(yt)**2*abs(ytau)**2 - 9/4*yb*abs(ytau)**4

def beta_ytau(nLoop, g1,g2,yt,yb,ytau,g3,lambda_):
    if nLoop == 1:
        return -9/4*g1**2*ytau - 9/4*g2**2*ytau + 3*ytau*abs(yb)**2 + 3*ytau*abs(yt)**2 + (5/2)*ytau*abs(ytau)**2
    if nLoop == 2:
        return (1371/200)*g1**4*ytau + (27/20)*g1**2*g2**2*ytau + (5/8)*g1**2*ytau*abs(yb)**2 + (17/8)*g1**2*ytau*abs(yt)**2 + (537/80)*g1**2*ytau*abs(ytau)**2 - 23/4*g2**4*ytau + (45/8)*g2**2*ytau*abs(yb)**2 + (45/8)*g2**2*ytau*abs(yt)**2 + (165/16)*g2**2*ytau*abs(ytau)**2 + 20*g3**2*ytau*abs(yb)**2 + 20*g3**2*ytau*abs(yt)**2 + 6*lambda_**2*ytau - 12*lambda_*ytau*abs(ytau)**2 - 27/4*ytau*abs(yb)**4 + (3/2)*ytau*abs(yb)**2*abs(yt)**2 - 27/4*ytau*abs(yb)**2*abs(ytau)**2 - 27/4*ytau*abs(yt)**4 - 27/4*ytau*abs(yt)**2*abs(ytau)**2 - 3*ytau*abs(ytau)**4


#####################
# Quartic Couplings #
#####################

def beta_lambda_(nLoop, g1,g2,yt,yb,ytau,lambda_,g3):
    if nLoop == 1:
        return (27/200)*g1**4 + (9/20)*g1**2*g2**2 - 9/5*g1**2*lambda_ + (9/8)*g2**4 - 9*g2**2*lambda_ + 24*lambda_**2 + 12*lambda_*abs(yb)**2 + 12*lambda_*abs(yt)**2 + 4*lambda_*abs(ytau)**2 - 6*abs(yb)**4 - 6*abs(yt)**4 - 2*abs(ytau)**4
    if nLoop == 2:
        return -3411/2000*g1**6 - 1677/400*g1**4*g2**2 + (1887/200)*g1**4*lambda_ + (9/20)*g1**4*abs(yb)**2 - 171/100*g1**4*abs(yt)**2 - 9/4*g1**4*abs(ytau)**2 - 289/80*g1**2*g2**4 + (117/20)*g1**2*g2**2*lambda_ + (27/10)*g1**2*g2**2*abs(yb)**2 + (63/10)*g1**2*g2**2*abs(yt)**2 + (33/10)*g1**2*g2**2*abs(ytau)**2 + (108/5)*g1**2*lambda_**2 + (5/2)*g1**2*lambda_*abs(yb)**2 + (17/2)*g1**2*lambda_*abs(yt)**2 + (15/2)*g1**2*lambda_*abs(ytau)**2 + (4/5)*g1**2*abs(yb)**4 - 8/5*g1**2*abs(yt)**4 - 12/5*g1**2*abs(ytau)**4 + (305/16)*g2**6 - 73/8*g2**4*lambda_ - 9/4*g2**4*abs(yb)**2 - 9/4*g2**4*abs(yt)**2 - 3/4*g2**4*abs(ytau)**2 + 108*g2**2*lambda_**2 + (45/2)*g2**2*lambda_*abs(yb)**2 + (45/2)*g2**2*lambda_*abs(yt)**2 + (15/2)*g2**2*lambda_*abs(ytau)**2 + 80*g3**2*lambda_*abs(yb)**2 + 80*g3**2*lambda_*abs(yt)**2 - 32*g3**2*abs(yb)**4 - 32*g3**2*abs(yt)**4 - 312*lambda_**3 - 144*lambda_**2*abs(yb)**2 - 144*lambda_**2*abs(yt)**2 - 48*lambda_**2*abs(ytau)**2 - 3*lambda_*abs(yb)**4 - 42*lambda_*abs(yb)**2*abs(yt)**2 - 3*lambda_*abs(yt)**4 - lambda_*abs(ytau)**4 + 30*abs(yb)**6 - 6*abs(yb)**4*abs(yt)**2 - 6*abs(yb)**2*abs(yt)**4 + 30*abs(yt)**6 + 10*abs(ytau)**6


#########################
# Scalar Mass Couplings #
#########################

def beta_mu(nLoop, g1,g2,yt,yb,ytau,lambda_,mu,g3):
    if nLoop == 1:
        return -9/10*g1**2*mu - 9/2*g2**2*mu + 12*lambda_*mu + 6*mu*abs(yb)**2 + 6*mu*abs(yt)**2 + 2*mu*abs(ytau)**2
    if nLoop == 2:
        return (1671/400)*g1**4*mu + (9/8)*g1**2*g2**2*mu + (72/5)*g1**2*lambda_*mu + (5/4)*g1**2*mu*abs(yb)**2 + (17/4)*g1**2*mu*abs(yt)**2 + (15/4)*g1**2*mu*abs(ytau)**2 - 145/16*g2**4*mu + 72*g2**2*lambda_*mu + (45/4)*g2**2*mu*abs(yb)**2 + (45/4)*g2**2*mu*abs(yt)**2 + (15/4)*g2**2*mu*abs(ytau)**2 + 40*g3**2*mu*abs(yb)**2 + 40*g3**2*mu*abs(yt)**2 - 60*lambda_**2*mu - 72*lambda_*mu*abs(yb)**2 - 72*lambda_*mu*abs(yt)**2 - 24*lambda_*mu*abs(ytau)**2 - 27/2*mu*abs(yb)**4 - 21*mu*abs(yb)**2*abs(yt)**2 - 27/2*mu*abs(yt)**4 - 9/2*mu*abs(ytau)**4


#############################
# Vacuum-expectation Values #
#############################

def beta_v(nLoop, g1,g2,yt,yb,ytau,v,xiGauge,g3,lambda_):
    if nLoop == 1:
        return (3/20)*xiGauge*g1**2*v + (3/4)*xiGauge*g2**2*v + (9/20)*g1**2*v + (9/4)*g2**2*v - 3*v*abs(yb)**2 - 3*v*abs(yt)**2 - v*abs(ytau)**2
    if nLoop == 2:
        return (9/200)*xiGauge**2*g1**4*v + (9/20)*xiGauge**2*g1**2*g2**2*v - 9/8*xiGauge**2*g2**4*v + (9/200)*xiGauge*g1**4*v + (9/20)*xiGauge*g1**2*g2**2*v - 9/20*xiGauge*g1**2*v*abs(yb)**2 - 9/20*xiGauge*g1**2*v*abs(yt)**2 - 3/20*xiGauge*g1**2*v*abs(ytau)**2 - 9/8*xiGauge*g2**4*v - 9/4*xiGauge*g2**2*v*abs(yb)**2 - 9/4*xiGauge*g2**2*v*abs(yt)**2 - 3/4*xiGauge*g2**2*v*abs(ytau)**2 - 1293/800*g1**4*v - 27/80*g1**2*g2**2*v - 5/8*g1**2*v*abs(yb)**2 - 17/8*g1**2*v*abs(yt)**2 - 15/8*g1**2*v*abs(ytau)**2 + (271/32)*g2**4*v - 45/8*g2**2*v*abs(yb)**2 - 45/8*g2**2*v*abs(yt)**2 - 15/8*g2**2*v*abs(ytau)**2 - 20*g3**2*v*abs(yb)**2 - 20*g3**2*v*abs(yt)**2 - 6*lambda_**2*v + (27/4)*v*abs(yb)**4 - 3/2*v*abs(yb)**2*abs(yt)**2 + (27/4)*v*abs(yt)**4 + (9/4)*v*abs(ytau)**4